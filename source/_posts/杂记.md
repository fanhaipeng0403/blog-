---
title: 杂记
date: 2016-12-27 14:42:25
tags:
categories: Others

---

## 数据相关
<div class="inline_editor_content" id="__w2_uwFEdmK_content"><span class="inline_editor_value"><div id="CxoZEE"></div><span class="rendered_qtext">Platforms:<br><span class="qlink_container"><a href="http://zillabyte.com" rel="noopener nofollow" target="_blank" onclick="return Q.openUrl(this);" class="external_link" data-qt-tooltip="zillabyte.com" data-tooltip="attached">Zillabyte</a></span> (Big data made easy)<br><span class="qlink_container"><a href="http://hadoop.apache.org/" rel="noopener nofollow" target="_blank" onclick="return Q.openUrl(this);" class="external_link" data-qt-tooltip="apache.org" data-tooltip="attached">Hadoop</a></span> (opensource software from Apache)<br><span class="qlink_container"><a href="http://hortonworks.com/" rel="noopener nofollow" target="_blank" onclick="return Q.openUrl(this);" class="external_link" data-qt-tooltip="hortonworks.com" data-tooltip="attached">Hortonworks</a></span> (enterprise Hadoop distribution)<br><span class="qlink_container"><a href="http://cloudera.com/" rel="noopener nofollow" target="_blank" onclick="return Q.openUrl(this);" class="external_link" data-qt-tooltip="cloudera.com" data-tooltip="attached">Cloudera</a></span> (Hadoop distribution)<br><span class="qlink_container"><a href="http://aws.amazon.com/elasticmapreduce" rel="noopener nofollow" target="_blank" onclick="return Q.openUrl(this);" class="external_link" data-qt-tooltip="amazon.com" data-tooltip="attached">Amazon Elastic MapReduce (EMR</a></span>) (Hadoop in the cloud<br><br>Visualization:<br><span class="qlink_container"><a href="http://tableausoftware.com" rel="noopener nofollow" target="_blank" onclick="return Q.openUrl(this);" class="external_link" data-qt-tooltip="tableausoftware.com" data-tooltip="attached">Tableau </a></span>(basic data visualization)<br><span class="qlink_container"><a href="http://zingchart.com" rel="noopener nofollow" target="_blank" onclick="return Q.openUrl(this);" class="external_link" data-qt-tooltip="zingchart.com">ZingChart </a></span>(paid solution, more powerful)<br><span class="qlink_container"><a href="http://d3js.org/" rel="noopener nofollow" target="_blank" onclick="return Q.openUrl(this);" class="external_link" data-qt-tooltip="d3js.org">D3.js </a></span>(Javascript library for doc manipulation)<br><span class="qlink_container"><a href="http://neo4j.org" rel="noopener nofollow" target="_blank" onclick="return Q.openUrl(this);" class="external_link" data-qt-tooltip="neo4j.org">Neo4J</a></span> (graph database)<br><br>Languages:<br><span class="qlink_container"><a href="http://python.org" rel="noopener nofollow" target="_blank" onclick="return Q.openUrl(this);" class="external_link" data-qt-tooltip="python.org">Python</a></span> (data science libraries like <span class="qlink_container"><a href="http://numpy.org" rel="noopener nofollow" target="_blank" onclick="return Q.openUrl(this);" class="external_link tooltip_parent" data-qt-tooltip="numpy.org" data-tooltip="attached">NumPy</a></span> and <span class="qlink_container"><a href="http://scipy.org" rel="noopener nofollow" target="_blank" onclick="return Q.openUrl(this);" class="external_link" data-qt-tooltip="scipy.org" data-tooltip="attached">SciPy.org</a></span>)<br><span class="qlink_container"><a href="http://www.r-project.org" rel="noopener nofollow" target="_blank" onclick="return Q.openUrl(this);" class="external_link" data-qt-tooltip="r-project.org">R</a></span> (for statistical computing and basic visualization)</span><div id="zMSYbQ"><div class="ContentFooter AnswerFooter" id="__w2_puLiLee_content_footer"><span id="aAJSbN"><span class="meta_num">4.5k</span> Views</span><span class="bullet"> · </span><a class="AnswerVoterListModalLink VoterListModalLink" href="/api/mobile_expanded_voter_list?type=answer&amp;key=L1gaq0dW9RY" id="__w2_OsAgI7s_modal_link" target="_blank">View Upvotes</a><span id="GUzUHz"></span><span id="pNgQvU"></span></div></div></span><div class="hidden" id="__w2_uwFEdmK_loading"><span class="loading">Loading…</span></div></div> Linux系统中是通过ssh服务实现的远程登录功能，默认ssh服务端口号为 22。 Window系统上 Linux 远程登录客户端有SecureCRT, Putty, SSH Secure Shell等，本文以Putty为例来登录远程服务器。 ------ wrapper 包装..比如把一些现成的东西 自己加些新的功能再用一样..  ---------------

注意变量和函数参数(形参和实参)的区别

形参是函数的占位符,实参是填充物,可以是一个实体,也可以是变量指代物,变量名和参数名建议一致的.


------
列表推导式,列表解析式,([] -----> ()生成器表达式), 式,就是expression

从一个基本的可迭代对象(可以用for的),推导出另一个可迭代对象o

任何列表表达式,都可以用map函数实现

------
生成器 ,函数 yield
迭代器, 类的方法有魔法方法__iter__ ,__next__

```
In [13]: class Fibs:
    ...:     def __init__(self,n=10):
    ...:         self.a=0
    ...:         self.b=1
    ...:         self.n=n
    ...:     def __iter__(self):  # 有了__iter__ ,实例可以被for,而且返回的还是self,依旧可以被for
    ...:         return self
    ...:     def __next__(self): #  这次 self 到下次self ,自动出发next函数
    ...:         if self.a<self.n:
    ...:             self.a,self.b=self.b,self.a+self.b
    ...:             return self.a
    ...:         else:
    ...:             raise StopIteration

In [14]: fib=Fibs()

In [15]: for i in fib:
    ...:     print (i)

1
1
2
3
5
8
13
```



-------
命名空间和作用域
命名空间是是对象和对象名的一种映射
作用域是对对象操作的效力范围

缩进表现的层级关系是作用域,整个文件也是一个作用域(对应模块)
调用作用域内的函数和方法都用.


```
模块
In [16]: import random

In [17]: random.randint(1,22)
Out[17]: 15

函数

In [24]: def function():
    ...:     a=1
    ...:     return a

In [25]: function.__name__
Out[25]: 'function'

In [26]: function.__init__
Out[26]: <method-wrapper '__init__' of function object at 0x7f9c431f90d0>

类
In [10]: class Myclass:
    ...:     'A simple example class'
    ...:     i=12345
    ...:     def f(self):
    ...:         return 'hello world'

In [11]: Myclass.i
Out[11]: 12345

In [12]: Myclass.f
Out[12]: <function __main__.Myclass.f>

In [13]: Myclass.f()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-13-9ff063a0dd28> in <module>()
----> 1 Myclass.f()

TypeError: f() missing 1 required positional argument: 'self'

In [27]: Myclass.f(a)
Out[27]: 'hello world'

等效于

In [14]: a=Myclass()

In [15]: a.f()

实力对象作为函数self的第一个参数

Out[15]: 'hello world'

```


-------

map

```
In [1]: def foo(a,b,c):
   ...:     return a+b+c

In [2]: map(foo,[1,2,3],[2,3,4],[4,5,6])
Out[2]: <map at 0x7f917353ac50>

In [3]: q=map(foo,[1,2,3],[2,3,4],[4,5,6])

In [4]: list(q)
Out[4]: [7, 10, 13]

```


-----

pytenv

http://www.jianshu.com/p/a23448208d9a

-----

python2和python3静态方法

python2

```
In [1]: class Myclass:
   ...:     i=1235
   ...:     def f():
   ...:         return 'gggg'

In [2]: Myclass.f()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-2-9ff063a0dd28> in <module>()
----> 1 Myclass.f()

TypeError: unbound method f() must be called with Myclass instance as first argument (got nothing instead)

In [3]: class Myclass:
   ...:     i=1235
   ...:     @staticmethod
   ...:     def f():
   ...:         return 'gggg'

In [4]: Myclass.f()
Out[4]: 'gggg'

python3

```


In [2]: class Myclass:
   ...:     i=12345
   ...:     def f():
   ...:         return 'gggg'

In [3]: Myclass.f()
Out[3]: 'gggg'

In [4]: class Myclass:
   ...:     i=12345
   ...:     def f():
   ...:         return 'gggg'

In [5]: Myclass.f()
Out[5]: 'gggg'

```
-----------------------------------------
闭包函数
lexical词汇的,closure闭合的,也叫工厂函数


外部函数为内部函数提供运行环境,而且生成的这个内函数可以继续使用这个变量

```
def f1(x):
    def f2(y):
        return x+y
     return  f2
```
f2被f1closure起来,f1提供给f2词汇lexical,x



注意闭包和装饰器的区别,闭包是生产一个函数,装饰器是在调用原来的函数前先做点别的事情.
------

实例方法,静态方法,类方法
(类方法和静态方法有特定的应用场景,一般用于统计类的属性,创建了多少实例等)

```
class Multi:
     #实例方法
     def imeth(self,x):
         print x
     #静态方法
     @staticmethod
     def smeth(x):
         print x
     #类方法
     def cmeth(cls,x):
         print x

#实例方法
instance=Multi()
instance.imeth(1)
或者
Multi.imeth(instance,1)

#静态方法

Multi.smeth(1)
instance.smeth(1)

#类方法
Multi.cmeth(1)
instance.cmeth(1)

------
多重继承的时候,如果被继承的父类的方法或者属性具有相同,传统类,按着绝对深度搜索

也可以明确指定继承谁的方法 run=Father.run


--------

Property

```
In [10]: class newprops:
    ...:     def getage(self):
    ...:         return self._age
    ...:     def setage(self,value):
    ...:         print ('set age:',value)
    ...:         self._age=value

In [11]: x=newprops()

In [12]: x.age=26

In [13]: x.age
Out[13]: 26

In [14]: x._age
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-14-d7ed5295a631> in <module>()
----> 1 x._age

AttributeError: 'newprops' object has no attribute '_age'

In [15]: x.setage(26)
set age: 26

In [16]: x._age
Out[16]: 26
```



```
In [6]: class newprops:
   ...:     def getage(self):
   ...:         return self._age
   ...:     def setage(self,value):
   ...:         print ('set age:',value)
   ...:         self._age=value
   ...:     age=property(getage,setage,None,None)

In [7]: x=newprops()

In [8]: x.age=26
set age: 26

In [9]: x.age
Out[9]: 26

In [16]: x._age
Out[16]: 26

```


----------------
函数设计


高内聚,一个函数只做一件事
低耦合, 不同函数之间关系要少越好

尽量不使用全局变量
如果函数的参数是如果是可变参数,尽量不要取改变它
函数不要过大

--------
函数内部变量如果找不到,就往上层找,上层找不到再找全局

```
In [3]: x=88

In [4]: def selector():
   ...:     print (x)

In [5]: selector()
88
```

但是要注意

```
In [3]: x=88

In [4]: def selector():
   ...:     print (x)
   ...:     x=99

In [5]: selector()

UnboundLocalError                         Traceback (most recent call last)
<ipython-input-5-2c35a205a0ba> in <module>()
----> 1 selector()

<ipython-input-4-9d8ab0e93fae> in selector()
      1 def selector():
----> 2     print (x)
      3     x=99

UnboundLocalError: local variable 'x' referenced before assignment


```


```
In [3]: def selector():
   ...:     import __main__
   ...:     print (__main__.x)
   ...:     x=99

In [4]: selector()
88
```


-----


__all__= 放置想让人调用的方法

from  module import * ,只能导入__all__


__file__ 模块放置的位置

__dict__  模块内变量和对应的值


-----

__name__ 如果模块被导入,那么__name__ 就是模块的名字

如果python module.py 这样应用这个模块,那么__name__ 会变成'__main__',即主程序


------
模块导入注意事项:

1.模块顶层代码的语句次序非常重要,代码定义和调用要分开
2.from 是复制变量名,而不是连接
3.from * 会让变量所属变得模糊
4.reload只会影响import的模块,不会影响from的导入
就说from module import function ,然后你修改了function,即使
你在模块里reload(module)也不会用到新的function
5.reload没有递归性
6.千万注意不要互相导入,即a到入b,b又要导入a

-----


上下文管理


__init__
__new___
__delet__
__getitem__

对象使用相应的操作,自动调用__xxx___

想使用上下文管理,对象的类必须有进入__enter__ 和出去__exit__ 方法


contextlib库
http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001478651770626de401ff1c0d94f379774cabd842222ff000

------
Agent 代理 通常指与用户接口的客户端程序
Proxy 代理 接收用户请求并将请求发给服务器,然后接收服务器回应并返回给用户 实际上Proxy的功能就是代替用户访问服务器,用户被隐藏.

---------
方法继承
```
class Super:
    def method(self):
         print "In super.method"


class Sub(Super):
     def method(self):
         print 'starting Sub.method'
         Super.method(self)     # Super.__init__(self,data)
         print 'ending Sub.method'
```

--------
抽象类

子类的继承父类,但是父类的方法确由继承它的子类决定,这样的类叫做抽象类.

(超类 父类 基类) (派生类 子类)  抽象类

被继承的类是对于子类来说,是超类,或者父类

基类,最基本的类,可以让别的类继承它,派生出其他类

派生类,子类

抽象类,只要方法名,确没有实时的方法

---------

构造    __new__  构造,较少用,可用于修改不可变类型
初始化 __init__ 初始化,只能返回None
析构   __del__   python内置的垃圾回收方法,当所有与实例相关的引用都被delet了,会被自动调用

```
In [7]: class A():
   ...:     def __init__(self):
   ...:         print "我被调用了"
   ...:     def __del__(self):
   ...:         print " 我被回收了"

In [8]: a=A()
我被调用了

In [9]: b=a

In [10]: del a

In [11]: del b
 我被回收了
```
-----------------------------

class A(int):pass

a=A(1)

实例化的时候要传入一个ini类型的数据
不传入的话,相当于调用int(),同理list(),tuple()
实际上就是在class A中没找到__new__ ,就去父类int中找__new__

-------

在使用魔法方法的时候,注意不要在类中再使用+, - a[1]这样的运算,防止死循环

所谓的魔法方法就是不是显性的调用它,在创建,删除,使用+ - * / [] . 这样的符号时候,自动调用

-------
import random
random.__all__
random.__file__
-------

not True and not True ,既不是也不是
== not ( True or True), 有一个是了就不行

------
# 容器协议

如果你希望定制的容器是不可变的话,你只需要定义__len__() 和 __getitem__方法
如果你希望定义的容器是可变额话,你除了定义__len__()和__getitem__方法,你还需要定义__setitem__() 和__delitem__方法


-----

getattr()函数

__getattr__()      访问到一个不存在的属性时的行为

__getattribute__() 访问属性时的行为
__setattr__()  设置属性时的行为
__delattr__()  删除属性时的行为

你可以在创建时可以定义__XXX__这些魔法方法,可以直接利用
property函数,指定那个现有函数等效于这些函数.



```
In [4]: class A():
   ...:     def __init__(self):
   ...:         self.x=1

In [5]: a=A()

In [6]: a.x
Out[6]: 1

In [7]: a.y
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-7-cc7049c6eeec> in <module>()
----> 1 a.y

AttributeError: 'A' object has no attribute 'y'

In [8]: getattr(a,'y','没有这个属性')
Out[8]: '没有这个属性'

```


--------
# 描述符

描述符就是将某种特殊类型的类(具有__get__ ,__set__,__delet__方法的类)的实例指派给另一个类的属性.

```
# 具有特殊类型的类
class MyDecriptor:
    def __get__(self,instance,owner):
         print("getting....,self,instance,owner)"
    def __set__(self,instance,owner):
         print("getting....,self,instance,owner)"
    def __delet__(self,instance):
         print("getting....,self,instance,owner)"


class Test:
#将上面这个类的实例指派给另一个的属性,这里就是Test类的x属性
    x=Mydecriptor()


test=Test()
然后调用属性
test.
这个时候会调用Mydecriptor的set方法

```
